#!/usr/bin/env python
from gevent import monkey; monkey.patch_all()
import sys
import os
from pkg_resources import require, DistributionNotFound, VersionConflict

# Check our requirements package
failed_deps = []
requirements_path = os.path.join(os.path.dirname(os.path.abspath(__file__)),
                       'requirements.txt')
with open(requirements_path, 'r') as f:
    for x in f:
        x = x.strip()
        if not x or x.startswith('#') or x.startswith('-e '):
            continue
        try:
            require(x)
        except (DistributionNotFound, VersionConflict):
            failed_deps.append(x)

if failed_deps:
    sys.exit("\nPython module dependency verification failed! \n\n"
             "The following dependencies are either missing or out of "
             "date: \n\t{}\n\nYou probably need to run --> sudo pip "
             "install -r requirements.txt\n"
             .format("\n\t".join(failed_deps)))
else:
    print 'Dependencies OK!'


# Keep it clean for development
print 'Removing pyc files...'
sys.stdout.flush()
for root, dir, files in os.walk('./src'):
    for filename in files:
        if filename[-4:] == '.pyc':
            full_path = os.path.join(root, filename)
            print 'removing {0}'.format(full_path)
            os.remove(full_path)
sys.dont_write_bytecode = True



from gevent import joinall, spawn
import argparse
import signal
from setproctitle import setproctitle; setproctitle('inbox')
import sqlalchemy
from alembic.config import Config as alembic_config
from alembic.script import ScriptDirectory

from inbox.server.config import config, load_config
from inbox.server.log import (configure_general_logging, get_logger,
                              log_uncaught_errors)
log = get_logger()


def debug(args=None):
    """ Run the server with autoreload."""
    from werkzeug.serving import run_with_reloader
    run_with_reloader(start)


def start(args=None):
    check_db()

    # commit = subprocess.check_output(["git", "describe", "--tags"])
    from inbox.server.models.tables.base import register_backends
    table_mod_for = register_backends()

    threads = []

    from inbox.server.util.concurrency import make_zerorpc

    # Start ZeroRPC mail sync server service
    from inbox.server.mailsync.service import SyncService
    sync_srv_loc = config.get('CRISPIN_SERVER_LOC', None)
    threads.append(make_zerorpc(SyncService, sync_srv_loc))

    # start ZeroRPC search server service
    from inbox.server.search import SearchService
    search_srv_loc = config.get('SEARCH_SERVER_LOC', None)
    threads.append(make_zerorpc(SearchService, search_srv_loc))

    # start webhook service
    from inbox.server.transactions.webhook import WebhookService
    webhook_srv_loc = config.get('WEBHOOK_SERVER_LOC', None)
    threads.append(make_zerorpc(WebhookService, webhook_srv_loc))

    from inbox.server.actions.base import rqworker
    threads.append(spawn(log_uncaught_errors(rqworker)))

    print """
\033[94m     Welcome to... \033[0m\033[1;95m
      _____       _
     |_   _|     | |
       | |  _ __ | |__   _____  __
       | | | '_ \| '_ \ / _ \ \/ /
      _| |_| | | | |_) | (_) >  <
     |_____|_| |_|_.__/ \___/_/\_\\  \033[0m

     Use CTRL-C to stop.
     """

    log.info("Recursion limit: {0}".format(sys.getrecursionlimit()))

    log.info('Providers currently supported: '\
             '{0}'.format(', '.join(table_mod_for.keys())))

    # hang out forever and run some services
    joinall(threads)


def sync(args):
    import zerorpc

    from inbox.server.models import session_scope
    from inbox.server.models.tables.base import Account
    from sqlalchemy.orm.exc import NoResultFound

    with session_scope() as db_session:
        try:
            account_id = db_session.query(Account.id).filter_by(
                email_address=args.email_address).one()[0]
        except NoResultFound:
            log.error("No record of account {0}".format(args.email_address))
            return

    mailsync_client = zerorpc.Client(timeout=15)
    mailsync_srv_loc = config.get('CRISPIN_SERVER_LOC', None)
    mailsync_client.connect(mailsync_srv_loc)
    try:
        if args.cmd == 'start':
            print mailsync_client.start_sync(account_id, dummy=args.dummy)
        elif args.cmd == 'startall':
            print mailsync_client.start_sync(dummy=args.dummy)
        elif args.cmd == 'stop':
            print mailsync_client.stop_sync(account_id)
        elif args.cmd == 'stopall':
            print mailsync_client.stop_sync()
        elif args.cmd == 'status':
            print mailsync_client.sync_status(account_id)
        else:
            sys.exit("No such command." )
    except zerorpc.exceptions.TimeoutExpired:
        sys.exit("Can't connect to sync service. Is it running? (./inbox start)")


def stop(args):
    print """
\033[91m     Cleaning up...
\033[0m"""
    # from inbox.server.app import stopserver
    # stopserver()

    print """
\033[91m     Stopped.
\033[0m"""
    # os.system("stty echo")
    sys.exit(0)


def console(args):
    from inbox.server.console import start_console
    start_console(args.email_address)


def api_server(args):
    from inbox.api.srv import app
    from gevent.wsgi import WSGIServer, WSGIHandler
    from inbox.server.log import get_logger
    from werkzeug.serving import run_with_reloader

    # start actions service
    from inbox.server.util.concurrency import make_zerorpc
    from inbox.server.transactions.actions import ListenerService
    action_srv_loc = config.get('ACTION_SERVER_LOC', None)
    make_zerorpc(ListenerService, action_srv_loc)

    from inbox.server.actions.base import rqworker
    spawn(log_uncaught_errors(rqworker))

    # gevent.pywsgi bullshit. see
    # http://stackoverflow.com/questions/9444405/gunicorn-and-websockets
    def log_request(self, *args):
        log = self.server.log
        if log:
            if hasattr(log, "info"):
                log.info(self.format_request(*args))
            elif hasattr(log, "debug"):
                log.debug(self.format_request(*args))
            elif hasattr(log, "warning"):
                log.warning(self.format_request(*args))
            elif hasattr(log, "error"):
                log.error(self.format_request(*args))
            else:
                log.write(self.format_request(*args))
    WSGIHandler.log_request = log_request

    inbox_logger = get_logger(purpose='api')
    @run_with_reloader
    def s():
        http_server = WSGIServer(('', int(args.port)), app, log=inbox_logger)
        inbox_logger.info("Starting API server on port {0}".format(args.port))
        http_server.serve_forever()
    s()


def search(args):
    import zerorpc

    try:
        c = zerorpc.Client(timeout=5)
        search_srv_loc = config.get('SEARCH_SERVER_LOC', None)
        c.connect(search_srv_loc)

        # XXX print something more useful here, like Subject: To: <snippet>
        # or something
        print c.search(args.namespace, args.query)
    except zerorpc.exceptions.TimeoutExpired:
        sys.exit("Can't connect. Is the sync server running? (./inbox start)")


def index(args):
    import zerorpc

    try:
        c = zerorpc.Client(timeout=5)
        search_srv_loc = config.get('SEARCH_SERVER_LOC', None)
        c.connect(search_srv_loc)
        c.index(args.namespace)
    except zerorpc.exceptions.TimeoutExpired:
        sys.exit("Can't connect. Is the sync server running? (./inbox start)")


def auth(args):
    check_db()

    from sqlalchemy.orm.exc import NoResultFound
    from inbox.util.url import NotSupportedError
    from inbox.server.models import session_scope
    from inbox.server.models.tables.base import Account
    from inbox.server.auth.base import get_handler

    email_address = args.email_address

    with session_scope() as db_session:
        auth_handler = get_handler(email_address)

        try:
            account = db_session.query(Account).filter_by(
                email_address=email_address).one()
        except NoResultFound:
            account = auth_handler.create_auth_account(db_session,
                                                       email_address)

        try:
            verified_account = auth_handler.verify_account(db_session, account)
        except NotSupportedError as e:
            print >>sys.stderr, str(e)
            sys.exit(1)

    return verified_account


def check_db():

    # Check database revision
    from inbox.server.models.ignition import db_uri  # needs to be after load_config()
    inbox_db_engine = sqlalchemy.create_engine(db_uri())

    # top-level, with setup.sh
    alembic_ini_filename = config.get('ALEMBIC_INI', None)
    assert alembic_ini_filename, 'Must set ALEMBIC_INI config var'
    assert os.path.isfile(alembic_ini_filename), \
        'Must have alembic.ini file at {}'.format(alembic_ini_filename)
    alembic_cfg = alembic_config(alembic_ini_filename)

    try:
        inbox_db_engine.dialect.has_table(inbox_db_engine, 'alembic_version')
    except sqlalchemy.exc.OperationalError:
        sys.exit("Databases don't exist! Run create_db.py")

    if inbox_db_engine.dialect.has_table(inbox_db_engine, 'alembic_version'):
        res = inbox_db_engine.execute('SELECT version_num from alembic_version')
        current_revision = [r for r in res][0][0]
        assert current_revision, \
            'Need current revision in alembic_version table...'

        script = ScriptDirectory.from_config(alembic_cfg)
        head_revision = script.get_current_head()
        log.info('Head database revision: {0}'.format(head_revision))
        log.info('Current database revision: {0}'.format(current_revision))

        if current_revision != head_revision:
            sys.exit('Outdated database! Migrate using `alembic upgrade head`')
        else:
            log.info('[OK] Database scheme matches latest')
    else:
        log.error('Un-stamped database! `create_db.py` should have done this... bailing.')
        return 1


def signal_handler(signal, frame):
    stop(None)


def main():
    signal.signal(signal.SIGINT, signal_handler)

    parser = argparse.ArgumentParser(description="Inbox App")
    parser.add_argument('-c', '--config', dest='config', default='config.cfg')
    subparsers = parser.add_subparsers()

    parser_api = subparsers.add_parser('api')
    parser_api.add_argument('-p', '--port', dest='port', default=5555)
    parser_api.set_defaults(func=api_server)

    parser_start = subparsers.add_parser('start')
    parser_start.set_defaults(func=start)

    parser_start = subparsers.add_parser('debug')
    parser_start.set_defaults(func=debug)

    parser_stop = subparsers.add_parser('stop')
    parser_stop.set_defaults(func=stop)

    parser_auth = subparsers.add_parser('auth',
                                        description="Auth an email account")
    parser_auth.add_argument('email_address',
                             help="Specify the email account to auth")
    parser_auth.set_defaults(func=auth)

    parser_console = subparsers.add_parser('console',
                                           description="REPL for crispin")
    parser_console.add_argument('-e', '--email-address',
                                help='Start console with crispin client for a particular user')
    parser_console.set_defaults(func=console)

    parser_sync = subparsers.add_parser('sync',
                                        description="Start/stop mail sync")
    parser_sync.add_argument('cmd', help='start or stop')
    parser_sync.add_argument('email_address',
                             help='Email address of the account to sync')
    parser_sync.add_argument('--dummy', action='store_true', default=False,
                             help="Don't connect to IMAP backend.")
    parser_sync.set_defaults(func=sync)

    parser_index = subparsers.add_parser('index', description="Index mail")
    parser_index.add_argument('namespace',
                              help='id of namespace to index mail')
    parser_index.set_defaults(func=index)

    parser_search = subparsers.add_parser('search', description="Search mail")
    parser_search.add_argument('namespace',
                               help='id of namespace to search mail')
    parser_search.add_argument('query', help='Term(s) to search for')
    parser_search.set_defaults(func=search)

    args = parser.parse_args()

    load_config(args.config)
    configure_general_logging()

    args.func(args)

    return 0

if __name__ == '__main__':
    sys.exit(main())
