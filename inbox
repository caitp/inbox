#!/usr/bin/env python
from gevent import monkey; monkey.patch_all()
from gevent import joinall, spawn
import argparse
import signal
import sys
import os
from setproctitle import setproctitle; setproctitle('inbox')
import sqlalchemy
from alembic.config import Config as alembic_config
from alembic.script import ScriptDirectory


# Keep it clean for development
print 'Removing pyc files...'
sys.stdout.flush()
for root, dir, files in os.walk('./src'):
    for filename in files:
        if filename[-4:] == '.pyc':
            full_path = os.path.join(root, filename)
            print 'removing {0}'.format(full_path)
            os.remove(full_path)
# TOFIX DEBUG PROD OMGWTFBBQ
sys.dont_write_bytecode = True


from inbox.util.misc import PidFile
from inbox.server.config import config, load_config
from inbox.server.log import (configure_general_logging, get_logger,
                              log_uncaught_errors)
log = get_logger()


def debug(args=None):
    """ Run the server with autoreload. TODO add debug flag to startup."""
    from werkzeug.serving import run_with_reloader
    run_with_reloader(start)


def start(args=None):
    with PidFile(config['PIDDIR'], 'inbox'):
        # commit = subprocess.check_output(["git", "describe", "--tags"])
        from inbox.server.models import init_db
        table_mod_for = init_db()

        threads = []

        # Start ZeroRPC api server service
        from inbox.server.util.concurrency import make_zerorpc
        from inbox.server.api import API
        api_srv_loc = config.get('API_SERVER_LOC', None)
        threads.append(make_zerorpc(API, api_srv_loc))

        # Start ZeroRPC mail sync server service
        from inbox.server.mailsync.service import SyncService
        sync_srv_loc = config.get('CRISPIN_SERVER_LOC', None)
        threads.append(make_zerorpc(SyncService, sync_srv_loc))

        # Start ZeroRPC contacts sync service
        from inbox.server.contacts.api import ContactService
        contacts_srv_loc = config.get('CONTACT_SERVER_LOC', None)
        threads.append(make_zerorpc(ContactService, contacts_srv_loc))

        # start ZeroRPC search server service
        from inbox.server.search import SearchService
        search_srv_loc = config.get('SEARCH_SERVER_LOC', None)
        threads.append(make_zerorpc(SearchService, search_srv_loc))

        from inbox.server.actions.base import rqworker
        threads.append(spawn(log_uncaught_errors(rqworker)))

        print """
    \033[94m     Welcome to... \033[0m\033[1;95m
        _____       _
        |_   _|     | |
        | |  _ __ | |__   _____  __
        | | | '_ \| '_ \ / _ \ \/ /
        _| |_| | | | |_) | (_) >  <
        |_____|_| |_|_.__/ \___/_/\_\\  \033[0m

        Use CTRL-C to stop.
        """

        log.info("Recursion limit: {0}".format(sys.getrecursionlimit()))

        log.info('Providers currently supported by Inbox: '\
                 '{0}'.format(', '.join(table_mod_for.keys())))

        # hang out forever and run some services
        joinall(threads)


def sync(args):
    import zerorpc

    from inbox.server.models import session_scope
    from inbox.server.models.tables.base import Account
    from sqlalchemy.orm.exc import NoResultFound

    with session_scope() as db_session:
        try:
            account_id = db_session.query(Account.id).filter_by(
                email_address=args.email_address).one()[0]
        except NoResultFound:
            log.error("No record of account {0}".format(args.email_address))
            return

    mailsync_client = zerorpc.Client(timeout=15)
    mailsync_srv_loc = config.get('CRISPIN_SERVER_LOC', None)
    mailsync_client.connect(mailsync_srv_loc)
    contacts_client = zerorpc.Client(timeout=15)
    contacts_srv_loc = config.get('CONTACT_SERVER_LOC', None)
    contacts_client.connect(contacts_srv_loc)
    try:
        if args.cmd == 'start':
            print mailsync_client.start_sync(account_id, dummy=args.dummy)
            print contacts_client.start_sync(account_id)
        elif args.cmd == 'startall':
            print mailsync_client.start_sync(dummy=args.dummy)
            print contacts_client.start_sync()
        elif args.cmd == 'stop':
            print mailsync_client.stop_sync(account_id)
            print contacts_client.stop_sync(account_id)
        elif args.cmd == 'stopall':
            print mailsync_client.stop_sync()
            print contacts_client.stop_sync()
        elif args.cmd == 'status':
            print mailsync_client.sync_status(account_id)
        else:
            print >>sys.stderr, "No such command."
            sys.exit(1)
    except zerorpc.exceptions.TimeoutExpired:
        print >>sys.stderr, \
            "Can't connect to sync service. Is it running? (./inbox start)"
        sys.exit(1)


def stop(args):
    print """
\033[91m     Cleaning up...
\033[0m"""
    # from inbox.server.app import stopserver
    # stopserver()

    print """
\033[91m     Stopped.
\033[0m"""
    # os.system("stty echo")
    sys.exit(0)


def console(args):
    from inbox.server.console import start_console
    start_console(args.email_address)


def search(args):
    import zerorpc

    try:
        c = zerorpc.Client(timeout=5)
        search_srv_loc = config.get('SEARCH_SERVER_LOC', None)
        c.connect(search_srv_loc)

        # XXX print something more useful here, like Subject: To: <snippet>
        # or something
        print c.search(args.namespace, args.query)
    except zerorpc.exceptions.TimeoutExpired:
        print >>sys.stderr, \
            "Can't connect. Is the sync server running? (./inbox start)"
        sys.exit(1)


def index(args):
    import zerorpc

    try:
        c = zerorpc.Client(timeout=5)
        search_srv_loc = config.get('SEARCH_SERVER_LOC', None)
        c.connect(search_srv_loc)
        c.index(args.namespace)
    except zerorpc.exceptions.TimeoutExpired:
        print >>sys.stderr, \
            "Can't connect. Is the sync server running? (./inbox start)"
        sys.exit(1)


def auth(args):
    from sqlalchemy.orm.exc import NoResultFound
    from inbox.util.url import NotSupportedError
    from inbox.server.models import session_scope, init_db
    from inbox.server.models.tables.base import Account
    from inbox.server.auth.base import get_handler

    email_address = args.email_address

    init_db()
    with session_scope() as db_session:
        auth_handler = get_handler(email_address)

        try:
            account = db_session.query(Account).filter_by(
                email_address=email_address).one()
        except NoResultFound:
            account = auth_handler.create_auth_account(db_session,
                                                       email_address)

        try:
            verified_account = auth_handler.verify_account(db_session, account)
        except NotSupportedError as e:
            print >>sys.stderr, str(e)
            sys.exit(1)

    return verified_account


def signal_handler(signal, frame):
    stop(None)


def main():
    signal.signal(signal.SIGINT, signal_handler)

    parser = argparse.ArgumentParser(description="Inbox App")
    parser.add_argument('-c', '--config', dest='config',
                        default='config.cfg')
    subparsers = parser.add_subparsers()

    parser_start = subparsers.add_parser('start')
    parser_start.set_defaults(func=start)

    parser_start = subparsers.add_parser('debug')
    parser_start.set_defaults(func=debug)

    parser_stop = subparsers.add_parser('stop')
    parser_stop.set_defaults(func=stop)

    parser_auth = subparsers.add_parser('auth',
                                        description="Auth an email account")
    parser_auth.add_argument('email_address',
                             help="Specify the email account to auth")
    parser_auth.set_defaults(func=auth)

    parser_console = subparsers.add_parser('console',
                                           description="REPL for crispin")
    parser_console.add_argument('-e', '--email-address',
                                help='Start console with crispin client for a particular user')
    parser_console.set_defaults(func=console)

    parser_sync = subparsers.add_parser('sync',
                                        description="Start/stop mail sync")
    parser_sync.add_argument('cmd', help='start or stop')
    parser_sync.add_argument('email_address',
                             help='Email address of the account to sync')
    parser_sync.add_argument('--dummy', action='store_true', default=False,
                             help="Don't connect to IMAP backend.")
    parser_sync.set_defaults(func=sync)

    parser_index = subparsers.add_parser('index', description="Index mail")
    parser_index.add_argument('namespace',
                              help='id of namespace to index mail')
    parser_index.set_defaults(func=index)

    parser_search = subparsers.add_parser('search',
                                          description="Search mail")
    parser_search.add_argument('namespace',
                               help='id of namespace to search mail')
    parser_search.add_argument('query', help='Term(s) to search for')
    parser_search.set_defaults(func=search)

    args = parser.parse_args()

    load_config(args.config)
    configure_general_logging()

    # Check database revision
    # import needs to be after load_config()
    from inbox.server.models import db_uri
    inbox_db_engine = sqlalchemy.create_engine(db_uri())

    # top-level, with setup.sh
    alembic_ini_filename = config.get('ALEMBIC_INI', None)
    assert alembic_ini_filename, 'Must set ALEMBIC_INI config var'
    assert os.path.isfile(alembic_ini_filename), \
        'Must have alembic.ini file at {}'.format(alembic_ini_filename)
    alembic_cfg = alembic_config(alembic_ini_filename)

    if inbox_db_engine.dialect.has_table(inbox_db_engine, "alembic_version"):
        res = inbox_db_engine.execute(
            "SELECT version_num from alembic_version")
        current_revision = [r for r in res][0][0]
        assert current_revision, \
            'Need current revision in alembic_version table...'

        script = ScriptDirectory.from_config(alembic_cfg)
        head_revision = script.get_current_head()
        log.info('Head database revision: {0}'.format(head_revision))
        log.info('Current database revision: {0}'.format(current_revision))

        if current_revision != head_revision:
            log.error(
                "Outdated database! Migrate using `alembic upgrade head`")
            return 1
        else:
            log.info('[OK] Database scheme matches latest')
    else:
        log.error('Un-stamped database! `create_db.py` should have done this... bailing.')
        return 1

    args.func(args)

    return 0

if __name__ == '__main__':
    sys.exit(main())
